## Java Design Patterns

This repository is make for to study the Design Patterns in Java language.Each of the package contain one pattern

### Creational Patterns.
- **Singleton:** This package contains the Singleton Connection class, in which the pattern is applied so that it can only be instantiated once time. The counter property is added only as a validator of what is happening

- **Factory Method:** This package contains a service interface that is implemented by the classes inside the services_concrete package, with which the required service class can be instantiated. The ServiceFactory is responsible for receiving a request for the type of service that is required through the TypeService, with which it instantiates the corresponding service class. This is a slightly different implementation from the original, making the Factory class a concrete class instead of being abstract, and in it, by means of an enum, the creation of the correct service is decided. In the original way, for every concrete class of service, there should be a concrete factory class that instantiates that service. The problem with this implementation is that it is much better than ours if the application has a dependency injection service, since if it does not, the instantiation is done directly in the client, causing it to have dependencies with classes such as services. If you have to add a new service class to our implementation, you only have to create the corresponding concrete service class, extend it from the service interface and add the case to the factory switch with the new instantiation.

- **Builder:** this pattern, a "Personal Computer" class was created with a constructor that requires 6 arguments in a specific order. To reduce complexity, we have created a "Personal Computer Builder" class with properties defined by default, and each set of methods return Personal Computer Builder to concatenate other methods and finally close with the method construct that returns the Personal Computer class. In this way we have no problem with the order of the arguments.

- **Prototype:** This pattern looks for the responsibility of creating a copy of an object to fall directly on the object to be copied instead of the constructor class, avoiding that dependency. It can be achieved by generating an interface with a clone method that returns an object from this same interface and is implemented in the class that creates the object that we want to clone.

- **Abstract Factory:** This is an extension of the factory method patterns. It is different in creating many objects of the same family. To do this, interfaces or abstract classes are used to isolate the factory classes and the products. Concrete factories of a family of products are created.

### Structural
- **Adapter:** The function of this pattern is solvated that two classes with incompatible interfaces can be used. In this case, we have a Round Hole class that is a form circular, and we have a Square peg record with form square. The Square class implement width method, while the Round Hole class consume get Radio. For solvent this problem, to create a Square Adapter class that extend Square Record and add getRadio method, taking over the delivery of the getRadio method to Round Hole class.

- **Bridge:** It is about separating the abstraction from the implementation. In this case, we have a TV and a smart remote control. By implementing an abstract remote class that implements the common functions of a remote control and making the device interface an attribute of this class, it allows us to extend many types of equipment by many types of remote controls.

- **Composite** When working with tree data structures and the elements have a common interface, this pattern can be used. In our case, we have a series of products that are stored in boxes that in turn can be stored in other boxes. All items have a total price, that is, each product has a price and the products in a box keep a total price. That is why a Salable interface is created and an ArrayList<Saleable> type attribute is placed in the box to be able to save the list of products and boxes within it.

- **Decorator** This pattern is responsible for increasing the capabilities or characteristics of a class without the need to modify it. This is achieved using the composition. Having the Target class that should not be changed, (for example, because it is being used), then we create an interface in which we will place the methods of the object class that interest us. We then implement this interface in an abstract base Decorator class, from which all other classes that augment the feature of the Target class will inherit. The base class will have an interface object as a property, which could be the Target or any other class that augments the feature and must be modified.